# Rustle Deploy

[![CI](https://github.com/iepathos/rustle-deploy/actions/workflows/ci.yml/badge.svg)](https://github.com/iepathos/rustle-deploy/actions/workflows/ci.yml)
[![Security](https://github.com/iepathos/rustle-deploy/actions/workflows/security.yml/badge.svg)](https://github.com/iepathos/rustle-deploy/actions/workflows/security.yml)
[![Release](https://github.com/iepathos/rustle-deploy/actions/workflows/release.yml/badge.svg)](https://github.com/iepathos/rustle-deploy/actions/workflows/release.yml)

A high-performance binary deployment tool for Rust that compiles execution plans into optimized, self-contained binaries and deploys them to remote hosts. Rustle Deploy bridges the gap between planning and execution by creating binaries with embedded execution data, eliminating network round-trips and providing 10x+ performance improvements over traditional SSH-based deployment approaches.

## 🚀 Overview

Rustle Deploy revolutionizes infrastructure automation by:

- **Compiling execution plans** into optimized, self-contained Rust binaries
- **Embedding execution data** directly into binaries to eliminate network overhead
- **Cross-compiling** for different target architectures (x86_64, ARM64, macOS, Linux)
- **Deploying via SSH/SCP** with automatic verification and rollback capabilities
- **Providing 10x+ performance** improvements over traditional SSH-based execution

### Key Features

- 🏗️ **Binary Compilation**: Converts execution plans into optimized Rust binaries
- 🎯 **Cross-Platform**: Supports Linux x86_64/ARM64, macOS, and Windows targets
- 📦 **Data Embedding**: Includes execution plans, modules, and static files in binaries
- 🚀 **Fast Deployment**: Parallel deployment to 100+ hosts in under 2 minutes
- 🔄 **Incremental Builds**: Smart caching reduces rebuild time by 90%+
- ✅ **Verification**: Automatic binary integrity checking and rollback support
- 📋 **Binary Output Management**: Reliable binary copying from cache or compilation sources
- 🔧 **Modular**: Integrates seamlessly with rustle-plan and rustle-exec pipeline

## 🚀 Quick Start

### Prerequisites

1. **Install Rust and Cargo**
   ```bash
   curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
   ```

2. **Setup Cross-Compilation (Required for multi-architecture support)**
   ```bash
   # Install cargo-zigbuild for better cross-compilation
   cargo install cargo-zigbuild
   
   # Install common cross-compilation targets
   rustup target add x86_64-unknown-linux-gnu
   rustup target add x86_64-unknown-linux-musl
   rustup target add aarch64-unknown-linux-gnu
   rustup target add aarch64-unknown-linux-musl
   
   # Or use the Justfile for complete setup
   just setup
   ```

3. **Install Rustle Deploy**
   ```bash
   cargo install rustle-deploy
   ```

### Basic Usage

1. **Compile and deploy an execution plan**
   ```bash
   # Basic deployment
   rustle-deploy plan.json
   
   # With verification and parallel deployment
   rustle-deploy plan.json --verify --parallel 8
   ```

2. **Pipeline integration**
   ```bash
   # Complete automation pipeline
   rustle-parse playbook.yml | \
     rustle-plan --strategy binary-hybrid | \
     rustle-deploy --verify | \
     rustle-exec
   ```

## 🏗️ Architecture

Rustle Deploy implements a sophisticated binary compilation and deployment pipeline:

### Components

1. **Execution Plan Parser**: Processes rustle-plan JSON output into structured deployment plans
2. **Binary Compiler**: Cross-compiles Rust binaries with embedded execution data
3. **Deployment Manager**: Handles parallel deployment, verification, and rollback
4. **Compilation Cache**: Intelligent caching for incremental builds
5. **Binary Output Management**: Reliable copying from cache, project, or memory sources
6. **Cross-Platform Support**: Target detection and toolchain management

### Process Flow

```
Execution Plan → Binary Compilation → Deployment → Verification
      ↓                   ↓               ↓           ↓
   Parse JSON         Cross-compile    SSH/SCP     Checksum
   Extract tasks      Embed data       Deploy      Validate
   Use target info    Optimize         Parallel    Rollback
   from plan
```

### Target Architecture Detection

Rustle-deploy uses target architecture information from the execution plan generated by rustle-plan. This ensures consistency across the pipeline:

- **rustle-plan**: Determines target architectures based on inventory and host information
- **rustle-deploy**: Uses the compilation requirements from the plan for cross-compilation
- **Fallback**: Manual override via `--target` or localhost detection for testing

## 📁 Project Structure

```
rustle-deploy/
├── src/
│   ├── bin/
│   │   └── rustle-deploy.rs       # Main CLI binary
│   ├── deploy/
│   │   ├── mod.rs                 # Deployment management
│   │   ├── manager.rs             # Deployment orchestration
│   │   ├── compiler.rs            # Binary compilation
│   │   ├── deployer.rs            # Remote deployment
│   │   ├── cache.rs               # Compilation caching
│   │   └── verification.rs        # Deployment verification
│   ├── compiler/
│   │   ├── mod.rs                 # Compilation components
│   │   ├── embedding.rs           # Data embedding
│   │   ├── cross_compile.rs       # Cross-compilation
│   │   └── optimization.rs        # Binary optimization
│   ├── types/
│   │   ├── mod.rs                 # Type definitions
│   │   ├── deployment.rs          # Deployment structures
│   │   ├── compilation.rs         # Compilation structures
│   │   └── inventory.rs           # Inventory parsing
│   └── lib.rs                     # Library entry point
├── tests/
│   ├── deploy/                    # Deployment tests
│   ├── compiler/                  # Compilation tests
│   └── integration/               # End-to-end tests
├── specs/                         # Technical specifications
├── examples/                      # Usage examples
└── target/                        # Build artifacts
```

## 🛠️ Development Workflow

### Building and Running
```bash
# Build rustle-deploy
cargo build --release

# Install locally
cargo install --path .

# Run with example plan
cargo run -- examples/simple_plan.json

# Development with hot reloading
cargo watch -x "run -- --help"
```

### Deployment Commands
```bash
# Compile only (no deployment)
rustle-deploy plan.json --compile-only

# Deploy existing binaries
rustle-deploy plan.json --deploy-only

# Incremental compilation
rustle-deploy plan.json --incremental --cache-dir ~/.rustle/cache

# Cross-platform deployment
rustle-deploy plan.json --target x86_64-unknown-linux-gnu
rustle-deploy plan.json --target aarch64-unknown-linux-gnu

# Cleanup deployed binaries (requires plan with host info)
rustle-deploy --cleanup plan.json

# Verification and rollback
rustle-deploy plan.json --verify
rustle-deploy --rollback deployment-id-123
```

### Testing and Quality
```bash
# Run all tests
cargo test

# Integration tests
cargo test --test integration -- --ignored

# Cross-compilation tests
cargo test compiler::cross_compile

# Performance benchmarks
cargo bench

# Code coverage
cargo tarpaulin --out Html

# Linting and formatting
cargo clippy -- -D warnings
cargo fmt
```

## 🔧 Command Line Interface

```bash
rustle-deploy [OPTIONS] [EXECUTION_PLAN]

OPTIONS:
    -c, --config <FILE>            Configuration file for deployment settings
    -o, --output-dir <DIR>         Directory for compiled binaries [default: ./target]
    -t, --target <TRIPLE>          Target architecture (auto-detect from plan hosts)
        --cache-dir <DIR>          Compilation cache directory
        --incremental              Enable incremental compilation
        --rebuild                  Force rebuild of all binaries
        --deploy-only              Deploy existing binaries without compilation
        --compile-only             Compile binaries without deployment
        --cleanup                  Remove deployed binaries from targets
        --parallel <NUM>           Parallel compilation jobs [default: CPU cores]
        --timeout <SECONDS>        Deployment timeout per host [default: 120]
        --verify                   Verify binary integrity after deployment
        --rollback                 Rollback to previous binary version
    -v, --verbose                  Enable verbose output
        --dry-run                  Show what would be compiled/deployed

ARGS:
    <EXECUTION_PLAN>  Path to execution plan file (or stdin if -)
```

### Examples

```bash
# Basic deployment
rustle-deploy plan.json

# Compile for specific target
rustle-deploy plan.json --target x86_64-unknown-linux-gnu

# Fast incremental deployment
rustle-deploy plan.json --incremental --parallel 16

# Production deployment with verification
rustle-deploy plan.json --verify --timeout 300

# Pipeline integration
echo plan.json | rustle-deploy - --deploy-only
```

## 🔧 Configuration

### Environment Variables

```bash
# Compilation settings
export RUSTLE_DEPLOY_CACHE_DIR="~/.rustle/cache"
export RUSTLE_BINARY_SIZE_LIMIT="50MB"
export RUSTLE_CROSS_COMPILE_DOCKER="false"

# Deployment settings
export RUSTLE_DEPLOYMENT_TIMEOUT="120"
export RUSTLE_PARALLEL_JOBS="8"
export RUSTLE_VERIFY_DEPLOYMENTS="true"

# Logging
export RUST_LOG="rustle_deploy=info"
```

### Configuration File

Create `~/.rustle/config.toml`:

```toml
[deployment]
cache_dir = "~/.rustle/cache"
output_dir = "./target/deploy"
parallel_jobs = 8
default_timeout_secs = 120
verify_deployments = true

[compilation]
optimization_level = "release"
strip_symbols = true
static_linking = true
compression = true
binary_size_limit_mb = 50

[targets]
default_arch = "x86_64-unknown-linux-gnu"
supported_targets = [
    "x86_64-unknown-linux-gnu",
    "aarch64-unknown-linux-gnu",
    "x86_64-apple-darwin",
    "aarch64-apple-darwin"
]

[cross_compilation]
use_zigbuild = true
toolchain_auto_install = true
```

### Dependencies

```toml
[dependencies]
# Core runtime
tokio = { version = "1", features = ["full"] }
clap = { version = "4", features = ["derive"] }

# Serialization and data handling
serde = { version = "1", features = ["derive"] }
serde_json = "1"
serde_yaml = "0.9"

# Error handling and logging
anyhow = "1"
thiserror = "1"
tracing = "0.1"
tracing-subscriber = "0.3"

# Deployment and compilation
sha2 = "0.10"
flate2 = "1"
tar = "0.4"
tempfile = "3"
uuid = { version = "1", features = ["v4"] }

# SSH and networking
tokio-util = "0.7"

[build-dependencies]
cargo_metadata = "0.18"

[dev-dependencies]
proptest = "1"
mockall = "0.11"
criterion = "0.5"
```

## 🚀 Production Deployment

### Building for Production

```bash
# Optimized release build
RUSTFLAGS="-C target-cpu=native -C opt-level=3" cargo build --release

# Cross-platform builds (requires targets to be installed)
cargo build --release --target x86_64-unknown-linux-gnu
cargo build --release --target aarch64-unknown-linux-gnu
cargo build --release --target x86_64-apple-darwin

# Zig-based cross-compilation (recommended - no additional setup needed)
cargo install cargo-zigbuild
cargo zigbuild --release --target x86_64-unknown-linux-gnu

# Using Justfile recipes
just build-linux          # Build for common Linux targets
just build-zig x86_64-unknown-linux-musl   # Build specific target with Zig
just build-all-targets    # Build for all supported platforms
```

## 🔄 Cross-Compilation Support

Rustle Deploy supports cross-compilation for multiple target architectures. Here's how to set it up:

### Target Installation

```bash
# Check currently installed targets
rustup target list --installed

# Install common targets
just install-targets

# Or manually install specific targets
rustup target add x86_64-unknown-linux-gnu
rustup target add aarch64-unknown-linux-gnu

# Check which targets are missing
just check-targets
```

### Supported Targets

- `x86_64-unknown-linux-gnu` - Linux x86_64 with GNU libc
- `x86_64-unknown-linux-musl` - Linux x86_64 with musl libc (static linking)
- `aarch64-unknown-linux-gnu` - Linux ARM64 with GNU libc
- `aarch64-unknown-linux-musl` - Linux ARM64 with musl libc (static linking)
- `x86_64-apple-darwin` - macOS x86_64
- `aarch64-apple-darwin` - macOS ARM64 (M1/M2)

### Cross-Compilation Methods

1. **Standard Rust Cross-Compilation** (requires target toolchains)
   ```bash
   cargo build --release --target x86_64-unknown-linux-gnu
   ```

2. **Cargo-Zigbuild** (recommended - zero setup required)
   ```bash
   cargo zigbuild --release --target x86_64-unknown-linux-gnu
   ```

3. **Using Justfile Recipes**
   ```bash
   just build-target x86_64-unknown-linux-gnu
   just build-all-targets
   ```

## 📋 Binary Output Management

The compilation pipeline now reliably handles binary output regardless of whether binaries come from cache or fresh compilation:

```bash
# Test compilation with reliable binary output
cargo run --bin rustle-deploy plan.json --localhost-test

# Specify output directory
cargo run --bin rustle-deploy plan.json --output-dir ./binaries

# Force fresh compilation (no cache)
cargo run --bin rustle-deploy plan.json --rebuild
```

### Features

- **Source Tracking**: Automatically tracks whether binaries come from cache, project build, or memory
- **Strategy Pattern**: Multiple output strategies with automatic fallback
- **Cross-Platform**: Proper binary naming (`.exe` on Windows) handled automatically
- **Atomic Operations**: Prevents partial file corruption during copying
- **Verification**: Copy integrity verification with size checks

### CLI Examples

- `--localhost-test` now works reliably without manual cache copying
- `--output-dir` properly receives binaries from any source
- Cross-platform binary naming (`.exe` on Windows) handled automatically

### Performance Optimization

```bash
# Profile compilation performance
RUSTFLAGS="-C opt-level=3 -C target-cpu=native" cargo build --release

# Monitor deployment metrics
rustle-deploy plan.json --verify --verbose

# Benchmark deployment speed
cargo bench -- deployment_speed
```

## 📊 Performance Characteristics

### Benchmarks

- **Compilation**: 100+ host binaries compiled in <2 minutes
- **Deployment**: 80%+ reduction in network overhead vs SSH execution
- **Execution**: 10x+ performance improvement over traditional approaches
- **Cache efficiency**: 90%+ rebuild time reduction with incremental compilation
- **Binary size**: <50MB for typical deployments with compression

### Scalability

- Supports deployment to 1000+ hosts
- Parallel compilation up to CPU core count
- Efficient memory usage for large execution plans
- Incremental builds for rapid development iterations

## 🧪 Testing

### Test Suites

```bash
# Unit tests
cargo test --lib

# Integration tests
cargo test --test integration

# Cross-compilation tests
cargo test compiler::cross_compile

# Deployment simulation
cargo test --test deploy_simulation -- --ignored

# Performance benchmarks
cargo bench
```

### Test Infrastructure

```
tests/
├── fixtures/
│   ├── execution_plans/       # Sample execution plans
│   ├── inventories/           # Test inventory files
│   └── binaries/              # Pre-compiled test binaries
├── integration/
│   ├── compilation_tests.rs   # End-to-end compilation
│   ├── deployment_tests.rs    # Deployment verification
│   └── pipeline_tests.rs      # Complete pipeline tests
└── benchmarks/
    ├── compilation_bench.rs   # Compilation performance
    └── deployment_bench.rs    # Deployment performance
```

## 📋 Roadmap

### Current Status (v1.0)
- ✅ Basic execution plan parsing
- ✅ Binary compilation pipeline
- ✅ SSH-based deployment
- ✅ Cross-compilation support
- ✅ Verification and rollback

### Planned Features (v1.1+)
- 🔄 Advanced deployment strategies (blue-green, canary)
- 🔄 Container-based cross-compilation
- 🔄 Integration with monitoring systems
- 🔄 Web UI for deployment management
- 🔄 Plugin system for custom modules

## 🤝 Contributing

1. Follow the development guidelines in `CLAUDE.md`
2. Ensure all tests pass: `cargo test`
3. Run linting: `cargo clippy -- -D warnings`
4. Format code: `cargo fmt`
5. Update specs and documentation
6. Add integration tests for new features

## 📄 License

GPL-3.0 License - see [LICENSE](LICENSE) file for details.

---

**Rustle Deploy** - Revolutionizing infrastructure automation through binary compilation and deployment. 🚀